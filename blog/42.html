<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  
  <script src="/assets/js/close_copy.js"></script>
  

  
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <title>Netty学习笔记</title>

  <link rel="shortcut icon" type="image/x-icon" href="/assets/private/icons/huangdayu.png" />
  <link rel="stylesheet" href="/assets/css/main.css" />
</head><body a="light">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">博客首页</a><article>
  
  <h1 class="post-header">Netty学习笔记</h1>

  <p class="post-meta">
    <time datetime="2020-09-07 00:00:00 +0800">2020-09-07</time>
  </p>
  
  <h1 id="何为netty">何为Netty</h1>

<hr />

<p>  Netty是一个异步事件驱动的网络应用程序框架，用于快速开发可维护的高性能协议服务器和客户端。</p>

<h1 id="何为事件驱动">何为事件驱动</h1>

<hr />

<p>事件处理的两道工序：</p>

<table>
  <thead>
    <tr>
      <th>方法</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>事件分离器(Event Demultiplexer)</td>
      <td>将事件源（socket/file）的I/O时间分离出来（IO就绪事件，IO完成事件），并分传递到对应的I/O事件处理器。</td>
    </tr>
    <tr>
      <td>事件处理器(Event Handler)</td>
      <td>应用预先注册需要处理的事件及其事件处理器（回调函数）。</td>
    </tr>
  </tbody>
</table>

<p>事件分离器的两种模式：</p>

<table>
  <thead>
    <tr>
      <th>模式</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Reactor</td>
      <td>事件分离器负责等待文件描述符或socket为读写操作准备就绪，然后将就绪事件传递给对应的处理器，最后由处理器负责完成实际的读写工作。<strong>I/O操作由应用完成，调用事件处理器时，表示I/O就绪。</strong></td>
    </tr>
    <tr>
      <td>Proactor</td>
      <td>demultiplexor事件处理器负责发起异步I/O操作，将用户定义的数据缓冲区地址和数据大小传递给操作系统，操作系统进行I/O操作，事件分离器捕获IO操作完成事件，然后将事件传递给对应处理器。<strong>I/O操作由系统完成，调用事件处理器时，表示I/O完成。</strong></td>
    </tr>
  </tbody>
</table>

<!-- more -->

<h1 id="何为异步io">何为异步I/O</h1>

<hr />

<p>  常见的I/O模式有一下几种，Netty是多路复用模式。假设场景：用户想从水管管道取5000L水，但是这个水管的水流是断断续续的，那么他有以下几种方法：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">模式</th>
      <th>大白话</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">阻塞 I/O（blocking IO）</td>
      <td>他打开水龙头，在必须原地<strong>等待</strong>水量达到5000L，然后这个任务才完成。</td>
      <td>阻塞，同步I/O</td>
    </tr>
    <tr>
      <td style="text-align: left">非阻塞 I/O（nonblocking IO）</td>
      <td>他打开水龙头，然后去做别的事情，两分钟过来查看一次（<strong>轮询</strong>），直到水位达到500L，然后这个任务才完成。</td>
      <td>非阻塞，同步I/O</td>
    </tr>
    <tr>
      <td style="text-align: left">I/O 多路复用（ IO multiplexing）（事件驱动I/O）</td>
      <td>他加装多个水龙头，然后在水龙头的前端安装水滴传感器（<strong>阻塞</strong>），他在后台<strong>轮询</strong>各个传感器的数据，一旦得到A水龙头的水滴传感器已经被触发时，他就打开水龙头A接水，有一下几种机制select，epoll，iocp，kqueue，poll。</td>
      <td>非阻塞，同步I/O</td>
    </tr>
    <tr>
      <td style="text-align: left">信号驱动 I/O（ signal driven IO）</td>
      <td>他加装多个水龙头，然后在水龙头的前端安装水滴传感器，当水龙头A的水滴传感器触发时，<strong>主动</strong>通知他，他就打开水龙头A接水。</td>
      <td>非阻塞，同步I/O</td>
    </tr>
    <tr>
      <td style="text-align: left">异步 I/O（asynchronous IO）</td>
      <td>他加装多个水龙头，然后在水龙头的前端安装水量传感器，并且将水龙头打开，然后他就去做其他的事情了，当水来时，水量传感器统计已取的水量，达到5000L时，将多个水桶的水汇聚到一个桶里，让他<strong>直接使用</strong>。</td>
      <td>非阻塞，异步I/O</td>
    </tr>
  </tbody>
</table>

<h1 id="io多路复用模式">I/O多路复用模式</h1>

<hr />

<table>
  <thead>
    <tr>
      <th>模式</th>
      <th>方法</th>
      <th>说明</th>
      <th>最大连接数</th>
      <th>效率</th>
      <th>消息传递方式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>select</strong></td>
      <td>轮询</td>
      <td>同步非阻塞</td>
      <td>FD_SETSIZE宏定义</td>
      <td>FD的增加会造成线性遍历速度慢的“线性下降性能问题”</td>
      <td>内核需要将消息传递到用户空间，都需要内核拷贝动作</td>
    </tr>
    <tr>
      <td><strong>kQueue</strong></td>
      <td>回调</td>
      <td>同步非阻塞</td>
      <td>与epoll相似</td>
      <td>与epoll相似</td>
      <td>与epoll相似</td>
    </tr>
    <tr>
      <td><strong>iocp</strong></td>
      <td>通知</td>
      <td>异步</td>
      <td>待了解</td>
      <td>待了解</td>
      <td>待了解</td>
    </tr>
    <tr>
      <td><strong>poll</strong></td>
      <td>轮询</td>
      <td>同步非阻塞</td>
      <td>基于链表来存储没有最大连接数的限制</td>
      <td>与select一样</td>
      <td>与select一样</td>
    </tr>
    <tr>
      <td><strong>ePoll</strong></td>
      <td>回调</td>
      <td>同步非阻塞</td>
      <td>连接数有上限，效率与连接数成反比</td>
      <td>socket活跃大会有性能问题</td>
      <td>通过内核和用户空间共享一块内存来实现</td>
    </tr>
  </tbody>
</table>

<h1 id="netty示例解析">Netty示例解析</h1>

<hr />

<p>以下是一个经典示例：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">io.netty.bootstrap.ServerBootstrap</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.*</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.nio.NioEventLoopGroup</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.socket.SocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.channel.socket.nio.NioServerSocketChannel</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.handler.codec.http.HttpObjectAggregator</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.handler.codec.mqtt.MqttDecoder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.handler.codec.mqtt.MqttEncoder</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">io.netty.handler.timeout.IdleStateHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.yb.iot.mqtt.handler.ChannelPipelineHandler</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.yb.iot.mqtt.handler.InboundMessageHandler</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.concurrent.TimeUnit</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">NettyServer</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="cm">/**
         * NioEventLoopGroup是处理I / O操作的多线程事件循环，多种实现可选。
         * 使用多少个线程以及如何将它们映射到创建的通道取决于EventLoopGroup实现，甚至可以通过构造函数进行配置。
         * 在上文中提到，I/O多路复用机制有多种，Netty中提供了多种实现,，以Group尾缀的为多线程实现。
         */</span>
        <span class="nc">EventLoopGroup</span> <span class="n">bossGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NioEventLoopGroup</span><span class="o">();</span>
        <span class="nc">EventLoopGroup</span> <span class="n">workerGroup</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">NioEventLoopGroup</span><span class="o">();</span>
        
        <span class="k">try</span> <span class="o">{</span>
            <span class="cm">/**
             * 设置服务器的帮助程序类。
             */</span>
            <span class="nc">ServerBootstrap</span> <span class="n">serverBootstrap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ServerBootstrap</span><span class="o">();</span>

            <span class="cm">/**
             * bossGroup通常称为“老板”，接受传入的连接。
             * workerGroup通常称为“工人”，一旦老板接受连接并将注册的连接注册给工人，便处理已接受连接的流量。
             */</span>
            <span class="n">serverBootstrap</span><span class="o">.</span><span class="na">group</span><span class="o">(</span><span class="n">bossGroup</span><span class="o">,</span> <span class="n">workerGroup</span><span class="o">)</span>
                    <span class="cm">/**
                     * 指定IO模型
                     */</span>
                    <span class="o">.</span><span class="na">channel</span><span class="o">(</span><span class="nc">NioServerSocketChannel</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>

                    <span class="cm">/**
                     * 配置自定义的事件处理器。
                     */</span>
                    <span class="o">.</span><span class="na">childHandler</span><span class="o">(</span><span class="k">new</span> <span class="nc">ChannelInitializer</span><span class="o">&lt;</span><span class="nc">SocketChannel</span><span class="o">&gt;()</span> <span class="o">{</span>

                        <span class="nd">@Autowired</span>
                        <span class="kd">private</span> <span class="nc">InboundMessageHandler</span> <span class="n">inboundMessageHandler</span><span class="o">;</span>

                        <span class="cm">/**
                         * 初始化channel模型的上下文
                         * @param socketChannel
                         * @throws Exception
                         */</span>
                        <span class="nd">@Override</span>
                        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initChannel</span><span class="o">(</span><span class="nc">SocketChannel</span> <span class="n">socketChannel</span><span class="o">)</span> <span class="o">{</span>
                            <span class="cm">/**
                             * 事件处理器责任链，可以动态增删
                             * 可以进行例如协议编码解码，心跳，内容长度，粘包分包处理，读写处理等，
                             * Netty已经默认提供了多种标准协议的解码编码实现，全都在io.netty.handler.codec.*下，如MQTT，HTTP等。
                             */</span>
                            <span class="nc">ChannelPipeline</span> <span class="n">pipeline</span> <span class="o">=</span> <span class="n">socketChannel</span><span class="o">.</span><span class="na">pipeline</span><span class="o">();</span>

                            <span class="cm">/** 最大内容长度 */</span>
                            <span class="n">pipeline</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">HttpObjectAggregator</span><span class="o">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">64</span><span class="o">));</span>

                            <span class="cm">/** 心跳时间 */</span>
                            <span class="n">pipeline</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="s">"idleStateHandler"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">IdleStateHandler</span><span class="o">(</span><span class="mi">120</span><span class="o">,</span> <span class="mi">120</span><span class="o">,</span> <span class="mi">120</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">SECONDS</span><span class="o">));</span>

                            <span class="cm">/** 协议编码 */</span>
                            <span class="n">pipeline</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="nc">MqttEncoder</span><span class="o">.</span><span class="na">INSTANCE</span><span class="o">);</span>

                            <span class="cm">/** 协议解码 */</span>
                            <span class="n">pipeline</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="k">new</span> <span class="nc">MqttDecoder</span><span class="o">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">64</span><span class="o">));</span>

                            <span class="cm">/** 消息处理 */</span>
                            <span class="n">pipeline</span><span class="o">.</span><span class="na">addLast</span><span class="o">(</span><span class="n">inboundMessageHandler</span><span class="o">);</span>
                        <span class="o">}</span>
                    <span class="o">})</span>

                    <span class="cm">/**
                     * 配置EventLoopGroup模型的参数
                     */</span>
                    <span class="o">.</span><span class="na">option</span><span class="o">(</span><span class="nc">ChannelOption</span><span class="o">.</span><span class="na">SO_BACKLOG</span><span class="o">,</span> <span class="mi">128</span><span class="o">)</span>

                    <span class="cm">/**
                     * 配置Channel模型的参数
                     */</span>
                    <span class="o">.</span><span class="na">childOption</span><span class="o">(</span><span class="nc">ChannelOption</span><span class="o">.</span><span class="na">SO_KEEPALIVE</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>

            <span class="cm">/**
             * 绑定并开始接受传入的连接，ChannelFuture支持I/O完成事件监听。
             */</span>
            <span class="nc">ChannelFuture</span> <span class="n">channelFuture</span> <span class="o">=</span> <span class="n">serverBootstrap</span><span class="o">.</span><span class="na">bind</span><span class="o">(</span><span class="mi">1883</span><span class="o">).</span><span class="na">sync</span><span class="o">();</span>

            <span class="cm">/**
             * 注册等待Socket服务器关闭。
             */</span>
            <span class="n">channelFuture</span><span class="o">.</span><span class="na">channel</span><span class="o">().</span><span class="na">closeFuture</span><span class="o">().</span><span class="na">sync</span><span class="o">();</span>

        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">InterruptedException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="cm">/**
             * 优雅的关闭并退出服务
             */</span>
            <span class="n">workerGroup</span><span class="o">.</span><span class="na">shutdownGracefully</span><span class="o">();</span>
            <span class="n">bossGroup</span><span class="o">.</span><span class="na">shutdownGracefully</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>EventLoopGroup与Channel的实现对应关系如下：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">单线程模型</th>
      <th style="text-align: center">多线程模型/主从线程模型</th>
      <th style="text-align: center">通道模型</th>
      <th style="text-align: center">模式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">EpollEventLoop.class</td>
      <td style="text-align: center">EpollEventLoopGroup.class</td>
      <td style="text-align: center">EpollServerSocketChannel.class</td>
      <td style="text-align: center">epoll</td>
    </tr>
    <tr>
      <td style="text-align: center">KQueueEventLoop.class</td>
      <td style="text-align: center">KQueueEventLoopGroup.class</td>
      <td style="text-align: center">KQueueServerSocketChannel.class</td>
      <td style="text-align: center">kQueue</td>
    </tr>
    <tr>
      <td style="text-align: center">NioEventLoop.class</td>
      <td style="text-align: center">NioEventLoopGroup.class</td>
      <td style="text-align: center">NioServerSocketChannel.class</td>
      <td style="text-align: center">select</td>
    </tr>
    <tr>
      <td style="text-align: center"><del>AioEventLoop.class</del></td>
      <td style="text-align: center"><del>AioEventLoopGroup.class</del></td>
      <td style="text-align: center"><del>AioServerSocketChannel.class</del></td>
      <td style="text-align: center"><del>iocp</del></td>
    </tr>
  </tbody>
</table>

<p>Netty重要组件：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">类</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Channel</td>
      <td style="text-align: center">管道对象</td>
    </tr>
    <tr>
      <td style="text-align: center">ChannelPipeline</td>
      <td style="text-align: center">管道事件处理器责任链</td>
    </tr>
    <tr>
      <td style="text-align: center">ChannelHandler</td>
      <td style="text-align: center">管道事件处理器的接口</td>
    </tr>
    <tr>
      <td style="text-align: center">ChannelHandlerContext</td>
      <td style="text-align: center">管道事件处理器的上下文</td>
    </tr>
    <tr>
      <td style="text-align: center">ChannelFuture</td>
      <td style="text-align: center">管道异步操作的结果</td>
    </tr>
    <tr>
      <td style="text-align: center">ByteBuf</td>
      <td style="text-align: center">管道一帧数据的对象，字节容器，通过引用计数的方式实现内存回收</td>
    </tr>
  </tbody>
</table>

<h1 id="参考文档">参考文档</h1>

<ul>
  <li><a href="https://netty.io/wiki/">Netty Wiki</a></li>
  <li><a href="https://www.epubit.com/bookDetails?id=N25822">Netty 实战 中文版</a></li>
  <li><a href="http://simyy.cn/2020/07/19/netty/">Netty设计原理</a></li>
  <li><a href="http://ifeve.com/category/netty/">并发编程网 Netty</a></li>
  <li><a href="https://www.lagou.com/lgeduarticle/16213.html">linux下select/poll/epoll机制的比较</a></li>
  <li><a href="https://segmentfault.com/a/1190000003063859">Linux IO模式及 select、poll、epoll详解</a></li>
  <li><a href="https://www.infoq.cn/article/netty-threading-model">Netty 系列之 Netty 线程模型</a></li>
  <li><a href="https://my.oschina.net/7001/blog/1480153">深入研究Netty之线程模型详解</a></li>
  <li><a href="https://www.cnblogs.com/yeyang/p/12580805.html">Netty学习之IO模型</a></li>
  <li><a href="http://www.jasongj.com/java/nio_reactor/">Java进阶（五）Java I/O模型从BIO到NIO和Reactor模式</a></li>
</ul>
<br/>
<a style="display: block;text-align:right;" href="/">博客首页</a>
<br/>
<p style="display: block;text-align:center;">©2012-2023 huangdayu.cn(大鱼叔叔的博客) 版权所有，未经授权，不得转载。</p>
<br/></article>


      </div>
    </main>
  </body>
</html>