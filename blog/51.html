<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  
  <script src="/assets/js/close_copy.js"></script>
  

  
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  <title>整洁架构学习笔记</title>

  <link rel="shortcut icon" type="image/x-icon" href="/assets/private/icons/huangdayu.png" />
  <link rel="stylesheet" href="/assets/css/main.css" />
</head><body a="light">
    <main class="page-content" aria-label="Content">
      <div class="w">
        <a href="/">博客首页</a><article>
  
  <h1 class="post-header">整洁架构学习笔记</h1>

  <p class="post-meta">
    <time datetime="2021-08-08 00:00:00 +0800">2021-08-08</time>
  </p>
  
  <h2 id="前言">前言</h2>

<p>  Bob大叔早有耳闻，时至今日才拜读其大作，实在恨晚，收获颇丰，此为笔记。</p>

<!-- more -->

<h2 id="架构整洁之道">架构整洁之道</h2>

<hr />

<h3 id="设计与架构">设计与架构</h3>

<hr />

<h4 id="定义">定义</h4>

<p>  底层设计细节和高层架构信息是不可分割的。它们组合在一起，共同定义了整个软件系统，缺一不可。所谓的底层和高层本身就是一系列决策组成的连续体，并没有清晰的分界线。</p>

<h4 id="目标">目标</h4>

<p>  软件架构的终极目标是，用最小的人力成本来满足构建和维护该系统的需求。
  系统构建过程中采用优秀的、整洁的软件架构与设计以便减少构建成本，提高生产力，构建一个长期稳定的、持久优秀的系统。</p>

<h3 id="软件编程范式">软件编程范式</h3>

<hr />

<h4 id="结构化编程">结构化编程</h4>

<p>  结构化编程对程序控制权的直接转移进行了限制和规范。<code class="language-plaintext highlighter-rouge">if/else/for/while</code>等范式使得我们可以证伪程序单元，从而推导这个程序的正确性。这样的功能性降解拆分是架构设计领域最佳实践之一。</p>

<p>  数学是要将可证明的结论证明，而科学则是将需要证明的结论证伪，不能证伪则表明程序当下的正确性，测试是一个反证的过程。</p>

<h4 id="面相对象编程">面相对象编程</h4>

<p>  面向对象编程对程序控制权的间接转移进行了限制和规范。</p>

<h5 id="面向对象对于架构的意义">面向对象对于架构的意义</h5>

<p>  面向对象编程就是以对象为手段来对源代码中的依赖关系进行控制的能力，这种能力让软件架构师可以构建出某种插件式架构，让高层策略性组件与底层实现性组件相分离，底层组件可必编译成插件，实现独立于高层组件的开发和部署。</p>

<h4 id="函数式编程">函数式编程</h4>

<p>  函数式编程对程序中的赋值进行了限制和规范。</p>

<h3 id="系统价值维度">系统价值维度</h3>

<hr />

<h4 id="行为价值">行为价值</h4>

<p>  让系统按照需求文档的要求编写代码，调试代码，修复BUG，以实现文档定义的功能。</p>

<h4 id="架构价值">架构价值</h4>

<p>  让系统保持足够的灵活，用户持续不断的变更需求就像是不停地用一堆不同形状的拼图块，拼成一个新的形状。</p>

<h3 id="软件设计原则">软件设计原则</h3>

<hr />

<h4 id="单一职责原则srp">单一职责原则（SRP）</h4>

<p>  任何一个软件模块（代码块或者模块组件）都应该只对某一类行为者（对象）负责，它是改变这个软件模块的唯一理由。</p>

<h4 id="开放闭合原则ocp">开放闭合原则（OCP）</h4>

<p>  一个设计良好的计算机系统应该在不需要修改的前提下就可以轻易被扩展，通过新增代码来修改系统行为，而非只能靠修改原来的代码。</p>

<h4 id="里氏替换原则lsp">里氏替换原则（LSP）</h4>

<p>  在必须遵守同一个约定（抽象类、接口）的条件下，组件（子类、实现类）可以相互替换，以满足不同需求的目的。</p>

<h4 id="接口隔离原则isp">接口隔离原则（ISP）</h4>

<p>  使用抽象接口的方式，以避免在代码中引入不必要的依赖。简而言之，我只管使用，不关心实现。</p>

<h4 id="依赖反转原则dip">依赖反转原则（DIP）</h4>

<p>  组件之间，依赖关系应该是主动提供者与被动使用者的关系，而非倒置。高层策略性接口应该由提供者定义，而非实现者来定义。</p>

<h3 id="组件聚合原则">组件聚合原则</h3>

<hr />

<h4 id="复用发布等同原则rep">复用/发布等同原则（REP）</h4>

<p>  组件中的类，模块之间的关系必须是紧密联系的，他们之间应该有共同的主题或者大方向，一个组件不能由一组毫无关系的类和模块组成。他们具有应同样原因而被修改，更新，发布和使用的特征。</p>

<h4 id="共同闭包原则ccp">共同闭包原则（CCP）</h4>

<p>  是单一职责原则在组件设计种的应用，一个组件只存在一种变更的原因，这也就需要将可能会被一起修改的类（他们具有紧密的关系）集中到同一个组件中。</p>

<h4 id="共同复用原则crp">共同复用原则（CRP）</h4>

<p>  组件的主题是明确的，组件的类与接口是可以共同复用的。一个组件中，不应该依赖不需要的类，接口，模块或者组件，否则也将影响组件的稳定性。</p>

<h3 id="组件耦合原则">组件耦合原则</h3>

<hr />

<h4 id="无依赖环原则adp">无依赖环原则（ADP）</h4>

<p>  组件中不能出现循环依赖，这将使得组件之间会相互干扰，组件的修改将更加困难。它的目的是在组件层面隔离频繁的变更。</p>

<h4 id="稳定依赖原则sdp">稳定依赖原则（SDP）</h4>

<p>  组件的依赖关系必须要指向更稳定的方向。稳定组件的定义是不依赖任何组件或者是更新频繁的组件，所以不会有原因导致其需要被修改，这样的组件独立且稳定。所以，外部依赖越多，组件越不稳定，层层递增的依赖关系将导致组件的不稳定性加剧。</p>

<h4 id="稳定抽象原则sap">稳定抽象原则（SAP）</h4>

<p>  一个组件的抽象化程度应该与其稳定性保持一致。创造一个足够灵活、能够被扩展，而且不需要修改的类是可能的，而这正是我们所需要的。哪一种类符合这个原则呢？答案是抽象类。稳定性本身就隐含了对抽象化的要求，即依赖关系应该指向更抽象的方向。</p>

<h3 id="依赖关系原则">依赖关系原则</h3>

<hr />

<h4 id="单向依赖原则odp">单向依赖原则（ODP）</h4>

<p>  下游服务可以依赖上游服务，以提供服务，而上游服务不能依赖下游服务，如果有数据变化，可以通过发送通知的形式。当然，我觉得跟合理的做法是，他们都共同依赖Interface模块，以实现单向依赖和依赖隔离原则。</p>

<h4 id="依赖隔离原则dsp">依赖隔离原则（DSP）</h4>

<p>  高层次组件与低层次组件它们都依赖更加稳定的Interface模块，这样就可以做到它们各自的修改都不影响彼此。</p>

<h4 id="最小依赖原则ldp">最小依赖原则（LDP）</h4>

<p>  每一个组件都追求最小依赖，不要依赖非必要的组件，可以依赖可选择组件。这样做可以使得应用最小化，轻量化。</p>

<h3 id="软件架构">软件架构</h3>

<hr />

<h4 id="目的">目的</h4>

<p>  软件架构设计的主要目标是支撑软件系统的全生命周期，设计良好的架构可以让系统便于理解、易于修改、方便维护，并且能轻松部署。软件架构的终极目标就是最大化程序员的生产力，同时最小化系统的总运营成本。</p>

<h4 id="架构师的目标">架构师的目标</h4>

<p>  致力于让软件系统的可选项数量最大化，包括但不限于组件，数据库，架构模式，服务框架，中间件等。并且，最大限度地降低构建和维护一个系统所需的人力资源。</p>

<h4 id="策略与细节的关系">策略与细节的关系</h4>

<p>  将软件的高层策略与其底层实现隔离开，让高层策略与实现细节脱钩，使其策略部分完全不需要关心底层细节，当然也不会对这些细节有任何形式的依赖。设计策略接口是一回事，实现策略接口是另外一回事，设计策略接口时尽可能的不关注具体能否实现。例如，业务与具体的设备脱钩，业务与具体设备无关，它只需要使用抽象好的策略接口，具体使用哪一个设备，在使用时才确定，至于该设备能否实现该功能是两外一回事。</p>

<h4 id="用例与架构的关系">用例与架构的关系</h4>

<p>  一个设计良好的架构在行为上对系统最重要的作用就是明确和显式地反映系统设计意图的行为，使其在架构层面上可见。业务逻辑可以被视为是一组用例的集合。</p>

<h4 id="灵活架构的意义">灵活架构的意义</h4>

<p>  一个设计良好的架构应该通过保留可选项的方式，让系统在任何情况下都能方便地做出必要的变更。</p>

<h4 id="用例业务开发运行部署可选项之间的关系">用例（业务）、开发，运行，部署，可选项之间的关系</h4>

<p>  他们都是一个设计良好的架构所需要服务的对象。</p>

<h4 id="按领域进行水平分层">按领域进行水平分层</h4>

<p>  通过采用单一职责原则（SRP）和共同闭包原则（CCP），以及既定的系统设计意图来隔离那些变更原因不同的部分，集成变更原因相同的部分。这样我们就可以得到一个可以被解耦成若干个水平分层应用的系统，他可能有业务逻辑、领域普适的业务逻辑、数据库等组件，模块或者服务。</p>

<h4 id="按用例进行垂直解耦">按用例进行垂直解耦</h4>

<p>  按照用例进行业务的垂直划分，他们都有各自的UI，业务和数据库，新的用例与旧的用例将不会相互影响。</p>

<h4 id="解耦的目的">解耦的目的</h4>

<p>  系统的水平或垂直解耦是灵活架构的必要条件，他们与微服务还是单体服务都没有直接的关系。他们实现了开发的独立性和部署的独立性，开发时不相互干扰，部署时不相互冲突。</p>

<h4 id="代码的重复">代码的重复</h4>

<p>  水分分层导致的各层数据对象或视图模型重复的问题是表面重复，我们应该避免复用他们，否则将来的改动将面临更大的挑战。真正的重复是代码的结果是一致的，且改变是一致的。一定要小心避免对任何重复都要立即消除的应激反应模式中。</p>

<h4 id="解耦的模式">解耦的模式</h4>

<p>  源码级别的组件（模块）解耦，依赖级别的部署解耦，进程级别的服务解耦。</p>

<h4 id="解耦的意义">解耦的意义</h4>

<p>  一个设计良好的架构应该允许一个系统从单体结构开始，以单一文件的形式部署，然后逐渐成长为一组相互独立的可部署单元，甚至是独立的服务或者微服务。最后还能随着情况的变化，允许系统逐渐回退到单体结构。一个设计良好的架构在上述过程中还应该能保护系统的大部分源码不受变更影响。对整个系统来说，解耦模式也应该是一个可选项。一个系统所适用的解耦模式可能会随着时间而变化，优秀的架构师应该能预见这一点，并且做岀相应的对策。</p>

<h4 id="边界划分的意义">边界划分的意义</h4>

<p>  接口隔离与组件隔离相结合。这么做可以推迟或延后一些技术选型方面的细节性决策，以减少时间和避免问题，甚至避免纠结和决策失误。也为这些组件之间建立变更防火墙。</p>

<h4 id="如何划分边界">如何划分边界</h4>

<p>  判断他们之间有没有直接的关系，比如前端，业务与数据库，他们都没有直接的关系，所以需要划清边界，通过接口进行数据通信。这意味着业务中不应该依赖于数据库的特性，比如不能依赖MySQL的事务，也不能依赖MongoDB的原子性操作，也不需要考虑表结构。遗憾的是，现实往往不是这样的。</p>

<h4 id="io无关原则">IO无关原则</h4>

<p>  如何输入与显示，对业务来说是无关紧要的。无论你是控制台还是命令行。</p>

<h4 id="插件化架构">插件化架构</h4>

<p>  View，Business，Database它们都只依赖彼此之间的Interface，具体使用SQL还是NoSQL，使用Web还是GUI，使用Business A 还是Business B，让使用者在Application中决定。</p>

<h4 id="插件化架构的好处">插件化架构的好处</h4>

<p>  这将构建起了一面变更无法逾越的防火墙。换句话说，Business的更改将不影响View与Database，前提是要确保Interface的稳定。所以，边界的划分也得参考组件的变更原因与变化速率。这也是单一职责原则（SRP）的一种体现，是对依赖反转原则（DIP）和稳定抽象原则（SAP）与依赖隔离原则（DSP（自创））的具体应用。依赖箭头应该由底层具体实现细节指向高层抽象的方向。</p>

<h4 id="边界的理解">边界的理解</h4>

<p>  无论是源码层，部署层还是进程层，架构的边界都不是一成不变的，边界的划分模式也是你中有我，我总有你。他们既可以以一个整体对外提供服务，又可以以个体对外提供能力。一个系统中，一定会有高吞吐量的进程内调用，也会有低通信高延迟的服务间调用。边界的划分是组件解耦或者系统解耦的必要步骤，也是插件化结构的必要手段。通常情况下，边界有分层边界，组件边界，服务边界和系统边界，前两者属于软件架构中的边界。</p>

<h4 id="策略组件层次的定义">策略（组件）层次的定义</h4>

<p>  一条策略距离系统的输入/输出越远，它所属的层次就越高。</p>

<h4 id="策略组件层次的划分">策略（组件）层次的划分</h4>

<p>  架构设计的工作常常需要将组件重排组合成为一个有向无环图，依赖关系统一指向高层策略。变更原因,变更时间相同和同一层次的策略应在 SRP （单一职责原则）和 CCP （共同闭包原则）这两个原则的指导下合并为同一组件。</p>

<h4 id="业务实体与业务逻辑">业务实体与业务逻辑</h4>

<p>  业务实体是业务数据与业务逻辑的集合。业务逻辑是整个系统的核心，是高层次的组件，用户界面与数据库等底层组件实现应该以插件形式接入系统中。业务逻辑应该是系统中最独立、复用性最高的代码。</p>

<h4 id="架构设计的信条">架构设计的信条</h4>

<p>  良好的架构设计应该只关注用例，并能将它们与其他的周边因素隔离。框架，工具，包括交付方式都应该是一个可选项。避免让框架等外部因素主导我们的架构设计。关于测试，我们应该通过用例对象来调度业务实体对象，确保所有的测试都不需要依赖框架。所以，一个系统的架构应该着重于展示系统本身的设计，而并非该系统所使用的框架。所谓的MVC也只是架构输入输出的方式，不是架构的核心。</p>

<h4 id="整洁架构">整洁架构</h4>

<h5 id="常见的架构模式">常见的架构模式</h5>

<ol>
  <li>六边形架构：即端口与适配器架构</li>
  <li>DCI架构：Data-Context-Interactions（数据-场景-交互）</li>
  <li>BCE架构：Boundary Control Entity（边界-控制-实体）</li>
</ol>

<h5 id="整洁架构的特征">整洁架构的特征</h5>

<ol>
  <li>独立于框架：框架是一个工具，不能依赖框架来设计架构，系统不应该适应框架的需要；</li>
  <li>独立测试：业务逻辑可以脱离UI，DB，WEB服务进行独立测试；</li>
  <li>独立于UI：不需要修改系统的其他部分就可以变更UI，例如在不修改业务逻辑的情况下将UI从WEB切换到CLI；</li>
  <li>独立于DB：将业务逻辑与DB之间进行接口隔离解耦，这样就可以随需要切换数据库。（注意：前提是不要使用数据库的特性）；</li>
  <li>独立于外部服务：系统的业务逻辑不需要知道任何其他外部接口，如微服务提供者。</li>
</ol>

<p><img src="https://www.huangdayu.cn/assets/private/images/image-97.png" alt="" title="整洁的软件架构" /></p>

<h5 id="整洁架构设计图说明">整洁架构设计图说明</h5>

<ol>
  <li>源代码中的依赖关系，必须只指向同心圆的内层，基本上，外层圆代表的是机制，内层圆代表的是策略，即由低层机制指向高级策略。</li>
  <li>高层模块不应该依赖低层模块，两者都应该依赖其抽象。是单向依赖原则，依赖隔离原则的应用。</li>
  <li>源码层面的依赖关系一定要指向同心圆的内侧。层次越往内，其抽象和策略的层次越高，同时软件的抽象程度就越高，其包含的高层策略就越多。最内层的圆中包含的是最通用、最高层的策略，最外层的圆包含的是最具体的实现细节。</li>
  <li>实体 Entities：又称领域对象或业务对象，实体用于封装应用的业务规则。</li>
  <li>用例 Use Cases：用例或可理解为业务流程调度，调度的动作就是操作实体的业务逻辑。</li>
  <li>接口适配器 Interface Adapters：将高层组件与底层组件隔离，作为他们数据格式转换，数据路由的纽带。</li>
  <li>框架和驱动 Frameworks and Drivers：一般是由工具、数据库、Web 框架等组成的，例如Spring（IOC &amp; AOP）</li>
  <li>跨越边界调用：高层组件与底层组件直接的跨边界调用，不需要知道细节。ioc，rpc，tcp，http都是可选项。</li>
  <li>数据的传递：与依赖关系是反方向的，数据体一定要采用内层最方便使用的形式。</li>
</ol>

<p><img src="https://www.huangdayu.cn/assets/private/images/image-98.png" alt="" title="整洁的软件架构" /></p>

<p>  上图是加上本人理解的整洁架构设计模型。其重点强调各组件之间必须有强烈且明显的边界，各组件必须通过业务领域组件进行交互，不能彼此之间跨边界调用。业务领域组件与实现细节组件是在所有边界之间定义边界接口层，这一层只包含了接口以及接口调用的数据结构体，以实现跨边界调用，这样就使得个组件的依赖关系都指向了策略层次更高的接口模块，以Adapters与Components为例，无论是如何切换，只要不修改接口和数据结构体，那么他们将不会影响彼此，这是接口隔离原则与依赖隔离原则的具体应用，这将大大增加架构的灵活度。</p>

<h4 id="谦卑对象模式">谦卑对象模式</h4>

<p>  难以修改的，可直接使用的对象就是谦卑对象。谦卑对象存在于架构边界之间，如数据映射对象（DO），跨服务边界数据传输对象（DTO），展示器与视图交互对象（VO）等。运用谦卑对象模式，将大幅提高整个系统的可测试性。强大的可测试性是一个架构的设计是否优秀的显著衡量标准之一。</p>

<h4 id="不完全边界">不完全边界</h4>

<p>  通过组件隔离原则，接口隔离原则，接口适配模式构建不完全边界模式，这样既支持了系统扩展，也定义了一部分边界，以便进行可扩展架构的开发。</p>

<h4 id="层次与边界">层次与边界</h4>

<p>  业务逻辑是架构中策略层次最高的组件，而组件的边界设计是需要完整的边界，还是不完全的边界，或是可以暂时忽略的边界，这需要架构师持续观察系统的演进和边界成本的权衡，找到设置边界的优势超过其成本的拐点，那就是实现该边界的最佳时机。</p>

<h4 id="yagni原则">YAGNI原则</h4>

<p>  “You aren’t going to need it”，臆想中的需求事实上住往是不存在的。</p>

<h4 id="组件划分的规则">组件划分的规则</h4>

<ol>
  <li>组件的功能职责与角色；</li>
  <li>组件的变更原因和速率。</li>
</ol>

<h4 id="面向服务架构">面向服务架构</h4>

<p>  架构设计的任务就是找到高层策略与低层细节之间的架构边界，同时保证这些边界遵守依赖关系规则。所谓的面向服务架构本身只是一种比函数调用方式成本稍高的，分割应用程序行为的一种形式，与系统架构无关。</p>

<p>  不管是单体程序，还是多组件程序，系统架构都是由那些跨越架构边界的关键函数调用来定义的，并且整个架构必须遵守依赖关系规则。系统中许多其他的函数虽然也起到了隔离行为的效果，但它们显然并不具有架构意义。常见的如数据库。服务的情况也一样，服务这种形式说到底不过是一种跨进程/平台边界的函数调用而己。</p>

<h5 id="解耦合的谬论">解耦合的谬论</h5>

<p>  任何形式的共享数据行为都会导致强耦合，无论是进程间还是函数接口。下游服务做的每一次变更都会影响上游服务，这就是间接彼此耦合的，比如数据结构中的新增一个字段，彼此都得改动。</p>

<h5 id="开发部署和运维的谬论">开发、部署和运维的谬论</h5>

<p>  如果面向服务架构已经建立在间接耦合的基础上，那么它们的开发，部署和运维也必须彼此来协调进行，这就是所谓的横跨型变更（cross-cutting concern）问题，它是所有软件系统都要面对的问题，无论服务化还是非服务化的。所以，所谓的可以独立开发，部署和运维也就自欺欺人了。基于组件的单体服务依然可以达到构建大型系统的目标。系统的架构是由系统内部的架构边界，以及边界之间的依赖关系所定义的，与系统中各组件之间的调用和通信方式无关。</p>

<h5 id="基于组件的服务">基于组件的服务</h5>

<p>  面向服务的架构也可以按照SOLID原则来设计，组件的跨边界调用从函数调用变成了跨进程调用，切换底层实现细节服务将不影响高层策略服务。甚至可以做到函数调用和跨进程调用灵活切换。所以，系统的架构边界事实上并不落在服务之间，而是穿透所有服务，在服务内部以组件的形式存在。一个服务可能是一个独立组件，以系统架构边界的形式隔开。一个服务也可能由几个组件组成，其中的组件以架构边界的形式互相隔离。</p>

<h5 id="横跨型变更">横跨型变更</h5>

<p>  我们必须在服务内部采用遵守依赖关系原则的组件设计方式和SOLID的软件设计原则，才能处理横跨型变更问题。</p>

<h4 id="测试边界">测试边界</h4>

<p>  测试分为单元测试与集成测试，质量检查测试、功能性测试、Cucumber 测试、TDD 测试、BDD 测试、组件测试。</p>

<p>  测试组件通常是一个系统中最独立的组件。系统的正常运行并不需要用到测试组件，用户也不依赖于测试组件。测试组件的存在是为了支持开发过程，而不是运行过程。设计一个可测试的系统的首要原则是测试组件不要于多变的东西，譬如GUI往往是多变的。所以，测试因该独立与GUI之外来测试业务逻辑。</p>

<p>  设计测试专用HTTP API，将测试组件与业务应用程序隔离，排除结构性耦合（如Maven依赖），允许测试代码忽视安全限制，使用专用配置，将系统部署到测试状态，以使得测试与业务不相互影响。但不可否认的是，使用HTTP API测试，依然存在数据交互，是一种间接性耦合。</p>

<p>  测试组件在验证系统稳定性和预防问题复发中发挥驱动作用，所以得保持测试组件的可维护性，以持续发挥作用。</p>

<h4 id="整洁的嵌入式架构">整洁的嵌入式架构</h4>

<h5 id="固件的定义">固件的定义</h5>

<p>  与具体实现细节，具体技术，具体硬件信息息息相关，无法分割的，难以更改或不能移植的软件程序就是固定程序，所谓固件。固件是为了适配特定硬件，特定技术而设计的，所以不能耦合到业务代码中，这样对代码的生命周期的影响是致命的。</p>

<h5 id="隔离实现细节">隔离实现细节</h5>

<p>  在整洁的嵌入式结构中，硬件，处理器和操作系统是实现细节，而只有软件才是真正的业务逻辑，所以要抽象操作系统抽象成（OSAL），处理器抽象层（PAL）和硬件抽象成（HAL），利用面向接口编程的可替代性特性来灵活适配不同的操作系统，不同的处理器，不同的硬件，以实现整洁的嵌入式架构的目标，保持产品长期健康，延长项目的生命周期。</p>

<p><img src="https://www.huangdayu.cn/assets/private/images/image-99.png" alt="" title="整洁的嵌入式架构" /></p>

<h5 id="不要重复自己原则dry">不要重复自己原则（DRY）</h5>

<p>  通用的代码应该抽象成统一的对象，以便代码复用，这是整洁架构的一部分。</p>

<h4 id="小结">小结</h4>

<p>  架构设计的核心思想就是将软件设计原则，组件隔离原则，依赖管理原则从始至终，一以贯之。</p>

<h3 id="实现细节">实现细节</h3>

<hr />

<h4 id="main组件">Main组件</h4>

<p>  Main 组件是整个系统中的一个底层模块，它处于整洁架构的最外圈，主要负责为系统加载所有必要的信息（框架初始化，起始状态，配置信息，加载外部资源），然后再将控制权转交回系统的高层组件。也可以将Main组件视为一个插件，用架构边界将它与系统的其他部分隔离，这样将使得在框架与配置层面的变更更加容易。</p>

<h4 id="数据库与文件系统">数据库与文件系统</h4>

<p>  数据库是实现存储数据的一种手段，起到在硬盘和内存之间传递数据的作用，在使用时会转成列表、集合、堆栈、队列、树等各种数据结构，以方便使用，而无需关心以何种方式来储存。数据本身很重要，但数据库是一个底层的实现细节。一个优秀的架构师是不会让实现细节污染整（侵入）个系统架构的。</p>

<p>  数据库软件对于性能和特性的封装当然也底层实现细节，我们可以在数据库访问层（ORM &amp; DAO）利用它，而不需要让它与系统架构相关联。不同数据库软件的新能和特性差异，需要在数据库访问层屏蔽掉。</p>

<h4 id="web与gui">WEB与GUI</h4>

<p>  如果架构中没有将业务逻辑与UI分离，没有将控制器、展示器与交互器解耦，当新的需求是将GUI改成WEB时，这将是一个灾难性的需求。UI是一个实现细节，而GUI与WEB是UI的实现方式，是UI与业务逻辑之间数据输入输出的一种桥梁。</p>

<h4 id="框架与工具">框架与工具</h4>

<p>  使用框架，就相当于对框架做出长期的信任和承诺，如果框架未来的改变并不符合我们的预期或者需求，那么更改将带来无法预估的风险。其风险主要有框架严重侵入业务、与框架的斗争比框架帮助我们的时间长得多、框架的更新和发展存在不确定性、不同框架间将很难切换。所以，不要依赖框架，不要让框架污染核心代码，应该依据依赖关系原则，将它们当作核心代码的插件来管理，如果需要，将创建代理类来使用框架。</p>

<p>  比如<code class="language-plaintext highlighter-rouge">Spring</code>，包括各种<code class="language-plaintext highlighter-rouge">IOC</code>和<code class="language-plaintext highlighter-rouge">AOP</code>工具，业务对象应该对他们的存在是不知情的，我们因该将Spring的依赖关系注入到Main组件中，应该Main组件作为系统架构中最底层，依赖最多的组件。所以，无论是框架还是外部工具库，都是具体的实现细节，应该尽最大可能将他们隔离在业务之外，以避免他们的更改对业务产生影响。</p>

<p>  依赖需谨慎，更改两行泪。</p>

<h4 id="小结-1">小结</h4>

<p>  对于业务领域来讲，实现细节不重要，但在整体架构设计中，实现细节的重要性依然不可忽视。</p>

<h3 id="架构发展简史">架构发展简史</h3>

<hr />

<h4 id="水平分层架构">水平分层架构</h4>

<p>  根据需求实现的不同层次的分层架构。常见有Controller,Service,Repository这三层，但存在一下问题：1）大规模软件不仅仅有三层，2）无法直观的展现具体业务领域信息，3）容易造成跨层级调用的问题，架构设计的原则中要求Web控制器永远不应该直接访问数据库层。</p>

<h4 id="垂直切分架构">垂直切分架构</h4>

<p>  根据相关功能、业务概念或者聚合根（领域驱动设计原则中的术语）来切分。这个架构事实上直接将一个分层架构垂直切分层多个分层架构，水平分层架构中存在的问题并没有得到解决。</p>

<h4 id="领域隔离架构">领域隔离架构</h4>

<p>  根据领域将业务领域与具体实现细节（数据库、UI、第三方集成、框架等）隔离的架构。一般区分为内部代码（领域，Domain）与外部代码（基础设施，Infrastructure）。这是领域驱动设计理念下的成果，解决了水平分层架构中的问题。</p>

<h4 id="组件封装架构">组件封装架构</h4>

<p>  使用接口隔离原则与组件隔离原则将同一业务领域的一系列功能封装到一个组件中，统一对外提供服务。这是在C4模型（系统，容器，组件，类）驱动下的设计思想。这种组件在单体下是本地调用，在分布式中也可以支持远程调用。不过，需要注意的是，封装强调的是代码的可见性，组件中的实现细节不能直接被外部组件使用，这使得组件的定义与隔离相当重要，而且功能服务组件之间不应该存在数据交互，而是由业务组件或应用组件负责交互。组件的构建一般建立在模块或者项目之上，这是性能，复杂度和维护性与架构设计目的之间的取舍。</p>

<p>  面向服务的组件（微服务），面向模块的组件（单体）都属于组件封装架构范畴。</p>

<h4 id="组件插拔架构">组件插拔架构</h4>

<p>  在组件封装架构的基础上支持组件的插拔，又称插件化架构。他强调没一个插件都可以在运行时插拔，替换，且不影响主应用和核心业务的运行。</p>

<h4 id="小结-2">小结</h4>

<p>  代码的组织结构是架构设计的直观表达。如何组织代码树，模块间如何解耦合，组件间如何定义与隔离，这些都需要架构思想作为指导，同时也需要综合考虑团队条件与研发成本。</p>

<h3 id="总结">总结</h3>

<hr />

<p>  我们在谈论架构的时候到底在谈论什么？很长一段时间，我们游走于单体，集群，分布式，微服务，无服务，服务网格等这些名声大噪的名词之间。可事实是，它们并非属于架构范畴，它们仅仅是软件部署和服务提供的形式，或可称之为服务架构，使用它们的唯一原因是满足服务需求，而软件架构是它们的根基与支撑。所以，通常意义上的架构指的是软件架构，而不是什么业务架构、服务架构、技术架构、应用架构或产品架构。</p>

<p>  我终于明白，我们谈的是软件架构的目标与愿景。所以，架构的目标是用最小的人力成本来满足构建和维护系统的需求；架构的愿景是为系统保留更多的可选项，延长系统的发展周期和项目的生命周期。</p>

<p>  那架构师呢？当然是为架构的目标与愿景做出长期规划与演进指导思想，为架构的可持续发展奠定良好的基础。</p>

<p align="right">开元 4719年柒月初一</p>
<p align="right">西元 2021年08月08日</p>

<h3 id="追记">追记</h3>

<hr />

<p>  在读《架构整洁之道》之前，我曾写过<a href="/blog/44">《关于架构与架构师的思考》</a>和<a href="/blog/49">《关于灵活型架构的思考》</a>两篇博文，前者讨论架构的不同层次，衡量维度，选型标准和思考架构师的能力与职责，得出的结论是架构是应当是实用型的，而架构师应当是复合型的；后者则在思考通过代码组织结构，系统配置和组件隔离设计原则来构建灵活型架构。</p>

<p>  实用型架构强调满足当下，灵活型架构则憧憬持续满足架构的生命周期的需求，适应软件项目多变的特征。灵活型架构也是演进型架构，而整洁架构（或可以称为组件架构）则是实现灵活型架构一种架构形式和架构手段。</p>

<p>  我们要始终明确目标与手段的界限，摆好主谓宾。</p>

<h2 id="更新记录">更新记录</h2>

<hr />

<table>
  <thead>
    <tr>
      <th style="text-align: center">时间</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">2021-08-08</td>
      <td style="text-align: center">《架构整洁之道》读两遍与写完笔记与总结初稿</td>
    </tr>
    <tr>
      <td style="text-align: center">2021-09-04</td>
      <td style="text-align: center">《架构整洁之道》新增追记与调整补充</td>
    </tr>
    <tr>
      <td style="text-align: center">2021-09-07</td>
      <td style="text-align: center">《架构整洁之道》新增最小依赖原则（LDP）与调整补充</td>
    </tr>
    <tr>
      <td style="text-align: center">2021-09-14</td>
      <td style="text-align: center">修改对边界的理解</td>
    </tr>
    <tr>
      <td style="text-align: center">2022-01-23</td>
      <td style="text-align: center">原标题《Bob大叔著作读书笔记》改为《整洁架构学习笔记》</td>
    </tr>
  </tbody>
</table>
<br/>
<a style="display: block;text-align:right;" href="/">博客首页</a>
<br/>
<p style="display: block;text-align:center;">©2012-2023 huangdayu.cn(大鱼叔叔的博客) 版权所有，未经授权，不得转载。</p>
<br/></article>


      </div>
    </main>
  </body>
</html>